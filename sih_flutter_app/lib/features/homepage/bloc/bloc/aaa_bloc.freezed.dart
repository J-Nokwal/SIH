// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'aaa_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AaaEventTearOff {
  const _$AaaEventTearOff();

  _Dff Dff() {
    return const _Dff();
  }

  _wdw wdw() {
    return const _wdw();
  }
}

/// @nodoc
const $AaaEvent = _$AaaEventTearOff();

/// @nodoc
mixin _$AaaEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Dff,
    required TResult Function() wdw,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? Dff,
    TResult Function()? wdw,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Dff,
    TResult Function()? wdw,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Dff value) Dff,
    required TResult Function(_wdw value) wdw,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Dff value)? Dff,
    TResult Function(_wdw value)? wdw,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Dff value)? Dff,
    TResult Function(_wdw value)? wdw,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AaaEventCopyWith<$Res> {
  factory $AaaEventCopyWith(AaaEvent value, $Res Function(AaaEvent) then) =
      _$AaaEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AaaEventCopyWithImpl<$Res> implements $AaaEventCopyWith<$Res> {
  _$AaaEventCopyWithImpl(this._value, this._then);

  final AaaEvent _value;
  // ignore: unused_field
  final $Res Function(AaaEvent) _then;
}

/// @nodoc
abstract class _$DffCopyWith<$Res> {
  factory _$DffCopyWith(_Dff value, $Res Function(_Dff) then) =
      __$DffCopyWithImpl<$Res>;
}

/// @nodoc
class __$DffCopyWithImpl<$Res> extends _$AaaEventCopyWithImpl<$Res>
    implements _$DffCopyWith<$Res> {
  __$DffCopyWithImpl(_Dff _value, $Res Function(_Dff) _then)
      : super(_value, (v) => _then(v as _Dff));

  @override
  _Dff get _value => super._value as _Dff;
}

/// @nodoc

class _$_Dff implements _Dff {
  const _$_Dff();

  @override
  String toString() {
    return 'AaaEvent.Dff()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Dff);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Dff,
    required TResult Function() wdw,
  }) {
    return Dff();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? Dff,
    TResult Function()? wdw,
  }) {
    return Dff?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Dff,
    TResult Function()? wdw,
    required TResult orElse(),
  }) {
    if (Dff != null) {
      return Dff();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Dff value) Dff,
    required TResult Function(_wdw value) wdw,
  }) {
    return Dff(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Dff value)? Dff,
    TResult Function(_wdw value)? wdw,
  }) {
    return Dff?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Dff value)? Dff,
    TResult Function(_wdw value)? wdw,
    required TResult orElse(),
  }) {
    if (Dff != null) {
      return Dff(this);
    }
    return orElse();
  }
}

abstract class _Dff implements AaaEvent {
  const factory _Dff() = _$_Dff;
}

/// @nodoc
abstract class _$wdwCopyWith<$Res> {
  factory _$wdwCopyWith(_wdw value, $Res Function(_wdw) then) =
      __$wdwCopyWithImpl<$Res>;
}

/// @nodoc
class __$wdwCopyWithImpl<$Res> extends _$AaaEventCopyWithImpl<$Res>
    implements _$wdwCopyWith<$Res> {
  __$wdwCopyWithImpl(_wdw _value, $Res Function(_wdw) _then)
      : super(_value, (v) => _then(v as _wdw));

  @override
  _wdw get _value => super._value as _wdw;
}

/// @nodoc

class _$_wdw implements _wdw {
  const _$_wdw();

  @override
  String toString() {
    return 'AaaEvent.wdw()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _wdw);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Dff,
    required TResult Function() wdw,
  }) {
    return wdw();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? Dff,
    TResult Function()? wdw,
  }) {
    return wdw?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Dff,
    TResult Function()? wdw,
    required TResult orElse(),
  }) {
    if (wdw != null) {
      return wdw();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Dff value) Dff,
    required TResult Function(_wdw value) wdw,
  }) {
    return wdw(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Dff value)? Dff,
    TResult Function(_wdw value)? wdw,
  }) {
    return wdw?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Dff value)? Dff,
    TResult Function(_wdw value)? wdw,
    required TResult orElse(),
  }) {
    if (wdw != null) {
      return wdw(this);
    }
    return orElse();
  }
}

abstract class _wdw implements AaaEvent {
  const factory _wdw() = _$_wdw;
}

/// @nodoc
class _$AaaStateTearOff {
  const _$AaaStateTearOff();

  _ssad ssad() {
    return const _ssad();
  }

  _AaaInitial AaaInitial() {
    return const _AaaInitial();
  }
}

/// @nodoc
const $AaaState = _$AaaStateTearOff();

/// @nodoc
mixin _$AaaState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ssad,
    required TResult Function() AaaInitial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ssad,
    TResult Function()? AaaInitial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ssad,
    TResult Function()? AaaInitial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ssad value) ssad,
    required TResult Function(_AaaInitial value) AaaInitial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ssad value)? ssad,
    TResult Function(_AaaInitial value)? AaaInitial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ssad value)? ssad,
    TResult Function(_AaaInitial value)? AaaInitial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AaaStateCopyWith<$Res> {
  factory $AaaStateCopyWith(AaaState value, $Res Function(AaaState) then) =
      _$AaaStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$AaaStateCopyWithImpl<$Res> implements $AaaStateCopyWith<$Res> {
  _$AaaStateCopyWithImpl(this._value, this._then);

  final AaaState _value;
  // ignore: unused_field
  final $Res Function(AaaState) _then;
}

/// @nodoc
abstract class _$ssadCopyWith<$Res> {
  factory _$ssadCopyWith(_ssad value, $Res Function(_ssad) then) =
      __$ssadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ssadCopyWithImpl<$Res> extends _$AaaStateCopyWithImpl<$Res>
    implements _$ssadCopyWith<$Res> {
  __$ssadCopyWithImpl(_ssad _value, $Res Function(_ssad) _then)
      : super(_value, (v) => _then(v as _ssad));

  @override
  _ssad get _value => super._value as _ssad;
}

/// @nodoc

class _$_ssad implements _ssad {
  const _$_ssad();

  @override
  String toString() {
    return 'AaaState.ssad()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ssad);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ssad,
    required TResult Function() AaaInitial,
  }) {
    return ssad();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ssad,
    TResult Function()? AaaInitial,
  }) {
    return ssad?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ssad,
    TResult Function()? AaaInitial,
    required TResult orElse(),
  }) {
    if (ssad != null) {
      return ssad();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ssad value) ssad,
    required TResult Function(_AaaInitial value) AaaInitial,
  }) {
    return ssad(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ssad value)? ssad,
    TResult Function(_AaaInitial value)? AaaInitial,
  }) {
    return ssad?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ssad value)? ssad,
    TResult Function(_AaaInitial value)? AaaInitial,
    required TResult orElse(),
  }) {
    if (ssad != null) {
      return ssad(this);
    }
    return orElse();
  }
}

abstract class _ssad implements AaaState {
  const factory _ssad() = _$_ssad;
}

/// @nodoc
abstract class _$AaaInitialCopyWith<$Res> {
  factory _$AaaInitialCopyWith(
          _AaaInitial value, $Res Function(_AaaInitial) then) =
      __$AaaInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$AaaInitialCopyWithImpl<$Res> extends _$AaaStateCopyWithImpl<$Res>
    implements _$AaaInitialCopyWith<$Res> {
  __$AaaInitialCopyWithImpl(
      _AaaInitial _value, $Res Function(_AaaInitial) _then)
      : super(_value, (v) => _then(v as _AaaInitial));

  @override
  _AaaInitial get _value => super._value as _AaaInitial;
}

/// @nodoc

class _$_AaaInitial implements _AaaInitial {
  const _$_AaaInitial();

  @override
  String toString() {
    return 'AaaState.AaaInitial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _AaaInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ssad,
    required TResult Function() AaaInitial,
  }) {
    return AaaInitial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ssad,
    TResult Function()? AaaInitial,
  }) {
    return AaaInitial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ssad,
    TResult Function()? AaaInitial,
    required TResult orElse(),
  }) {
    if (AaaInitial != null) {
      return AaaInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ssad value) ssad,
    required TResult Function(_AaaInitial value) AaaInitial,
  }) {
    return AaaInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ssad value)? ssad,
    TResult Function(_AaaInitial value)? AaaInitial,
  }) {
    return AaaInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ssad value)? ssad,
    TResult Function(_AaaInitial value)? AaaInitial,
    required TResult orElse(),
  }) {
    if (AaaInitial != null) {
      return AaaInitial(this);
    }
    return orElse();
  }
}

abstract class _AaaInitial implements AaaState {
  const factory _AaaInitial() = _$_AaaInitial;
}

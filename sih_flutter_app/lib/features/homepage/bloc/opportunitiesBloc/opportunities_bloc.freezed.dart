// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'opportunities_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$OpportunitiesEventTearOff {
  const _$OpportunitiesEventTearOff();

  _loadOpportunities loadOpportunities() {
    return const _loadOpportunities();
  }
}

/// @nodoc
const $OpportunitiesEvent = _$OpportunitiesEventTearOff();

/// @nodoc
mixin _$OpportunitiesEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadOpportunities,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadOpportunities,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadOpportunities,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_loadOpportunities value) loadOpportunities,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_loadOpportunities value)? loadOpportunities,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_loadOpportunities value)? loadOpportunities,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpportunitiesEventCopyWith<$Res> {
  factory $OpportunitiesEventCopyWith(
          OpportunitiesEvent value, $Res Function(OpportunitiesEvent) then) =
      _$OpportunitiesEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpportunitiesEventCopyWithImpl<$Res>
    implements $OpportunitiesEventCopyWith<$Res> {
  _$OpportunitiesEventCopyWithImpl(this._value, this._then);

  final OpportunitiesEvent _value;
  // ignore: unused_field
  final $Res Function(OpportunitiesEvent) _then;
}

/// @nodoc
abstract class _$loadOpportunitiesCopyWith<$Res> {
  factory _$loadOpportunitiesCopyWith(
          _loadOpportunities value, $Res Function(_loadOpportunities) then) =
      __$loadOpportunitiesCopyWithImpl<$Res>;
}

/// @nodoc
class __$loadOpportunitiesCopyWithImpl<$Res>
    extends _$OpportunitiesEventCopyWithImpl<$Res>
    implements _$loadOpportunitiesCopyWith<$Res> {
  __$loadOpportunitiesCopyWithImpl(
      _loadOpportunities _value, $Res Function(_loadOpportunities) _then)
      : super(_value, (v) => _then(v as _loadOpportunities));

  @override
  _loadOpportunities get _value => super._value as _loadOpportunities;
}

/// @nodoc

class _$_loadOpportunities implements _loadOpportunities {
  const _$_loadOpportunities();

  @override
  String toString() {
    return 'OpportunitiesEvent.loadOpportunities()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _loadOpportunities);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadOpportunities,
  }) {
    return loadOpportunities();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadOpportunities,
  }) {
    return loadOpportunities?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadOpportunities,
    required TResult orElse(),
  }) {
    if (loadOpportunities != null) {
      return loadOpportunities();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_loadOpportunities value) loadOpportunities,
  }) {
    return loadOpportunities(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_loadOpportunities value)? loadOpportunities,
  }) {
    return loadOpportunities?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_loadOpportunities value)? loadOpportunities,
    required TResult orElse(),
  }) {
    if (loadOpportunities != null) {
      return loadOpportunities(this);
    }
    return orElse();
  }
}

abstract class _loadOpportunities implements OpportunitiesEvent {
  const factory _loadOpportunities() = _$_loadOpportunities;
}

/// @nodoc
class _$OpportunitiesStateTearOff {
  const _$OpportunitiesStateTearOff();

  _loading loading() {
    return const _loading();
  }

  _loaded loaded(
      {required ListopportunitiesResponse listopportunitiesResponse}) {
    return _loaded(
      listopportunitiesResponse: listopportunitiesResponse,
    );
  }
}

/// @nodoc
const $OpportunitiesState = _$OpportunitiesStateTearOff();

/// @nodoc
mixin _$OpportunitiesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            ListopportunitiesResponse listopportunitiesResponse)
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(ListopportunitiesResponse listopportunitiesResponse)?
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(ListopportunitiesResponse listopportunitiesResponse)?
        loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_loading value)? loading,
    TResult Function(_loaded value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_loading value)? loading,
    TResult Function(_loaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpportunitiesStateCopyWith<$Res> {
  factory $OpportunitiesStateCopyWith(
          OpportunitiesState value, $Res Function(OpportunitiesState) then) =
      _$OpportunitiesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpportunitiesStateCopyWithImpl<$Res>
    implements $OpportunitiesStateCopyWith<$Res> {
  _$OpportunitiesStateCopyWithImpl(this._value, this._then);

  final OpportunitiesState _value;
  // ignore: unused_field
  final $Res Function(OpportunitiesState) _then;
}

/// @nodoc
abstract class _$loadingCopyWith<$Res> {
  factory _$loadingCopyWith(_loading value, $Res Function(_loading) then) =
      __$loadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$loadingCopyWithImpl<$Res>
    extends _$OpportunitiesStateCopyWithImpl<$Res>
    implements _$loadingCopyWith<$Res> {
  __$loadingCopyWithImpl(_loading _value, $Res Function(_loading) _then)
      : super(_value, (v) => _then(v as _loading));

  @override
  _loading get _value => super._value as _loading;
}

/// @nodoc

class _$_loading implements _loading {
  const _$_loading();

  @override
  String toString() {
    return 'OpportunitiesState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            ListopportunitiesResponse listopportunitiesResponse)
        loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(ListopportunitiesResponse listopportunitiesResponse)?
        loaded,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(ListopportunitiesResponse listopportunitiesResponse)?
        loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_loading value)? loading,
    TResult Function(_loaded value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_loading value)? loading,
    TResult Function(_loaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _loading implements OpportunitiesState {
  const factory _loading() = _$_loading;
}

/// @nodoc
abstract class _$loadedCopyWith<$Res> {
  factory _$loadedCopyWith(_loaded value, $Res Function(_loaded) then) =
      __$loadedCopyWithImpl<$Res>;
  $Res call({ListopportunitiesResponse listopportunitiesResponse});
}

/// @nodoc
class __$loadedCopyWithImpl<$Res> extends _$OpportunitiesStateCopyWithImpl<$Res>
    implements _$loadedCopyWith<$Res> {
  __$loadedCopyWithImpl(_loaded _value, $Res Function(_loaded) _then)
      : super(_value, (v) => _then(v as _loaded));

  @override
  _loaded get _value => super._value as _loaded;

  @override
  $Res call({
    Object? listopportunitiesResponse = freezed,
  }) {
    return _then(_loaded(
      listopportunitiesResponse: listopportunitiesResponse == freezed
          ? _value.listopportunitiesResponse
          : listopportunitiesResponse // ignore: cast_nullable_to_non_nullable
              as ListopportunitiesResponse,
    ));
  }
}

/// @nodoc

class _$_loaded implements _loaded {
  const _$_loaded({required this.listopportunitiesResponse});

  @override
  final ListopportunitiesResponse listopportunitiesResponse;

  @override
  String toString() {
    return 'OpportunitiesState.loaded(listopportunitiesResponse: $listopportunitiesResponse)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _loaded &&
            const DeepCollectionEquality().equals(
                other.listopportunitiesResponse, listopportunitiesResponse));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(listopportunitiesResponse));

  @JsonKey(ignore: true)
  @override
  _$loadedCopyWith<_loaded> get copyWith =>
      __$loadedCopyWithImpl<_loaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            ListopportunitiesResponse listopportunitiesResponse)
        loaded,
  }) {
    return loaded(listopportunitiesResponse);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(ListopportunitiesResponse listopportunitiesResponse)?
        loaded,
  }) {
    return loaded?.call(listopportunitiesResponse);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(ListopportunitiesResponse listopportunitiesResponse)?
        loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(listopportunitiesResponse);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_loading value)? loading,
    TResult Function(_loaded value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_loading value)? loading,
    TResult Function(_loaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _loaded implements OpportunitiesState {
  const factory _loaded(
          {required ListopportunitiesResponse listopportunitiesResponse}) =
      _$_loaded;

  ListopportunitiesResponse get listopportunitiesResponse;
  @JsonKey(ignore: true)
  _$loadedCopyWith<_loaded> get copyWith => throw _privateConstructorUsedError;
}
